/**
 * FILE INFO
 * 1. getTest() - Assessment / Mock
 * 2. getAssessmentTest() - Get Assessment Test From Server
 * 3. getMockTest() - Get Practice Test From Server
 * 4. syncQuiz() - Sync Quiz by calling syncQuestions() for each question
 * 5. syncQuestions() -  Sync Each Question using question_data from server
 * 6. getSubjectList() - Generate Subject List
 * 7. timer() - Setup & Start Server Timer
 * 8. startTest() - Calls syncQuiz(), getSubjectList(), timer() & showQuestion() --> Calls showQuestion() for first question
 * 9. showQuestion() - Show Question by using index --> Fetch from question list (Question list from server)
 * 10. nextQuestion() - Show next question by index
 * 11. previousQuestion() - Show Previous question by index
 * 12. jumpToQuestion() - Jump to question by index
 * 13. nextSubject() - Show next subject by index
 * 14. completeTest() - Complete Test --> Final Submit
 * 15. submitAnswer() - Submit Each Question on click of one of the 4 buttons
 * 16. getUserAnswer() - Get User Answer generated by generateUserAnswer()
 * 17. generateUserAnswer() - Generate User Answers from data based on question type
 * 18. updateQuestionStatus() - Update Question Status - > Completed, Save & Maked For Review, Mark For Review, Cleared
 * 19. saveAndMarkForReview() - Marks Questions for Save and mark for review
 * 20. markForReviewAndNext() - Mark Question for review (locally)
 * 21. clearResponse() - Clear response
 * 22. getCircleClass() - Get Question status circle color
 * 23. toggleSidebar() -  Toggle Question status Sidebar
 * 24. checkNetworkStatus() -  Check Network Status
 * 25. ngOnInit() -  Get Quiz Basic Details from previous page and call getTest(), userProfile(), checkNetworkStatus()
 * 26. ngOnDestroy() -  Restore Website sidebar layout on page restore
 */

import {
  Component,
  OnInit,
  ViewChildren,
  ViewChild,
  QueryList,
  ElementRef,
  Renderer2,
} from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { NgxImageCompressService } from 'ngx-image-compress';
import { NetworkRequestService } from '../../../../../services/network-request.service';
import { TestService } from '../../../../../services/test.service';
import { MiscellaneousService } from '../../../../../services/miscellaneous.service';
import { environment } from '../../../../../../environments/environment';
import { Observable } from 'rxjs';
import * as _ from 'lodash';
import { UtilsService } from '../../../../../core/services/utils.service';
import { AlertService } from '../../../../../services/alert.service';
import { LocationStrategy } from '@angular/common';

@Component({
  selector: 'app-test',
  templateUrl: './test.component.html',
  styleUrls: ['./test.component.scss'],
  providers: [TestService]
})
export class TestComponent implements OnInit {
  constructor(
    private route: ActivatedRoute,
    private renderer: Renderer2,
    private networkRequest: NetworkRequestService,
    private test: TestService,
    private misc: MiscellaneousService,
    private utils: UtilsService,
    private alertService: AlertService,
    private locationStrategy: LocationStrategy,
    private imageCompress: NgxImageCompressService
  ) {
  }

  @ViewChildren('option') optionRef: QueryList<any>;
  @ViewChild('sidebar', { static: false }) sidebarRef: ElementRef;
  @ViewChild('fillUpInput', { static: false }) fillUpInputRef: ElementRef;
  @ViewChild('numericalInput', { static: false }) numericalInputRef: ElementRef;
  @ViewChild('subjectiveInput', { static: false }) subjectiveInputRef: ElementRef;
  @ViewChild('subjectiveInputImage', { static: false }) subjectiveInputImageRef: ElementRef;
  @ViewChild('mathjax', { static: false }) mathjax: ElementRef;

  env = environment;

  testObj: object = {};
  question: object;


  numericalAnswer: string = "";
  clicked: boolean = false;
  selectedContentId;

  onclickNumericalAnswer(x) {
    this.clicked = true
    this.numericalAnswer += x
  }

  onclickClearallAnswer() {
    this.clicked = false;
    this.numericalAnswer = "";
    this.urls = [];
    if (this.currentQuestion < this.totalQuestions - 1) {
      if (this.subjectiveInputImageRef) {
        this.renderer.setProperty(this.subjectiveInputImageRef.nativeElement, 'value', null);
      }
    }
  }

  onclickClearAnswer() {
    this.numericalAnswer = this.numericalAnswer.slice(0, -1);
  }


  testStatus = {
    testAvailable: true,
    cleared: false,
    review: false,
    sRreview: false,
    completed: false
  };

  // Question Count
  notAnswerdCount = [];
  completedCount = [];
  savedReviewCount = [];
  reviewCount = [];

  currentQuestion = 0;
  totalQuestions: any;
  testDuration: object = {};
  subjectObj: Array<object>;
  submittingQuestion = false;

  userProfileObj: any;

  questionSidebarActive: boolean;
  viewLengends = true;

  isMobile = this.utils.isMobile();
  maximizeScreen = false;
  file: any;
  localUrl: any;
  selectFile(event: any) {
    this.file = event.target.files[0];
    if (event.target.files && event.target.files[0]) {
      var reader = new FileReader();
      reader.onload = (event: any) => {
        this.localUrl = event.target.result;
        this.compressFile(this.localUrl)
      }
      reader.readAsDataURL(event.target.files[0]);
    }

  }
  imgResultAfterCompress: string;
  compressFile(image) {
    var orientation = -1;
    this.imageCompress.compressFile(image, orientation, 50, 50).then(
      result => {
        this.imgResultAfterCompress = result;
      }
    );
  }

  urls = [];
  showLoader = {
    visibility: false,
  };

  compressAndSendFile(image) {
    this.showLoader.visibility = true;
    var orientation = -1;
    this.imageCompress.compressFile(image, orientation, 50, 50).then(
      result => {
        this.networkRequest.postWithHeader(JSON.stringify({ "user_subjective_answer_image": result }), '/api/post_answer_image/')
          .subscribe(data => {
            this.urls.push(data);
            this.showLoader.visibility = false;
          }, error => {
            this.showLoader.visibility = false;
            console.log(error, "error");
          });
      });

  }

  onSelectFile(event) {
    if (event.target.files && event.target.files[0]) {
      var filesAmount = event.target.files.length;
      for (let i = 0; i < filesAmount; i++) {
        var reader = new FileReader();
        reader.onload = (event: any) => {
          this.localUrl = event.target.result;
          this.compressAndSendFile(this.localUrl);
        }
        reader.readAsDataURL(event.target.files[i]);
      }
    }
  }

  /**
   * Get Test On Page Load
   */
  getTest() {

    if (this.testObj['type'] === 'mock') {
      this.getMockTest();
    } else if (this.testObj['type'] === 'assessment') {
      this.getAssessmentTest();
    }
  }


  /**
   * Get Assessment Questions From server
   */
  getAssessmentTest() {

    this.misc.showLoader();
    this.networkRequest.getWithHeaders(`/api/assessmentpaper_questions/${this.testObj['id']}/`).subscribe(
      data => {
        // Check If Assessment Exam is available
        if (!data['exam_status']) {
          this.testStatus.testAvailable = true;
          this.startTest(data);
        } else {
          this.testStatus.testAvailable = false;
          this.testObj['exam_status'] = data['exam_status'];
        }
        this.misc.hideLoader();
      },
      error => {
        this.misc.hideLoader();
      }
    );
  }


  /**
   * Get Assessment Questions From server
   */
  getMockTest() {

    this.misc.showLoader();

    this.networkRequest.getWithHeaders(`/api/mockpaper_questions/${this.testObj['id']}/${this.testObj['attemptOrder']}/`)
      .subscribe(
        data => {
          if ((data['paper_status'])) {
            this.testStatus.testAvailable = false;
          } else {
            this.testStatus.testAvailable = true;
            this.startTest(data);
          }

          this.misc.hideLoader();
        },
        error => {
          this.misc.hideLoader();
        }
      );
  }


  /**
   * Syncs all the attempted Questions on page refresh to keep quiz in sync with previously submmitted quiz responses
   */
  syncQuiz() {

    for (const questionIndex in this.testObj['data']['questions']) {
      if (questionIndex) {
        this.syncQuestions(questionIndex).subscribe();
      }
    }
  }


  /**
   * Updates Test Object With Attempted Question data (from server) to keep the quiz in sync & mentain the state of
     previously attempted questions
    * Updates Single Questions State with user response data (from local) to keep the question in sync

    * 1. Sync Seleted Options
    * 2. Sync Fill Up Type Questions
    * 3. Sync Questions Attempted Status
    * 4. Sync Mark For Review Questions
    */
  syncQuestions(questionIndex, userResponse = null) {


    // Update Test Object With User Response to sync the view
    return new Observable(observer => {

      // Sync Question with user response
      if (userResponse) {
        this.testObj['data']['question_data'][questionIndex]['user_mcq_answer'] = userResponse['user_mcq_answer'];
        this.testObj['data']['question_data'][questionIndex]['user_string_answer'] = userResponse['user_string_answer'];
        this.testObj['data']['question_data'][questionIndex]['user_subjective_answer'] = userResponse['user_subjective_answer'];
        this.testObj['data']['question_data'][questionIndex]['user_subjective_answer_images'] = userResponse['user_subjective_answer_images'];
      }

      const question = this.testObj['data']['questions'][questionIndex];
      const questionData = this.testObj['data']['question_data'][questionIndex];

      // Sync MCQ & MCC Question's attempted options
      if (question['mcqtestcase'].length !== 0) {
        question['mcqtestcase'].forEach(option => {
          try {

            // Delete Previous Attempted status (to handle the case if user changes answer)
            delete option['attempted'];

            if (questionData['user_mcq_answer'].length !== 0) {

              if (questionData['user_mcq_answer'].includes(option.id)) {
                option['attempted'] = true;
              }
            } else {
              option['attempted'] = false;
            }
          } catch (err) {
            // Handle Errors Here
          }
        });
      }

      // Update Previously attempted fill up or numerical answer
      if (questionData['user_string_answer']) {
        this.testObj['data']['questions'][questionIndex]['user_string_answer'] = questionData['user_string_answer'];
      } else {
        this.testObj['data']['questions'][questionIndex]['user_string_answer'] = '';
      }

      // Update Previously attempted subjective text answer
      if (questionData['user_subjective_answer']) {
        this.testObj['data']['questions'][questionIndex]['user_subjective_answer'] = questionData['user_subjective_answer'];
      } else {
        this.testObj['data']['questions'][questionIndex]['user_subjective_answer'] = '';
      }

      // Update Previously attempted attempted subjective image answer
      if (questionData['user_subjective_answer_images']) {
        this.testObj['data']['questions'][questionIndex]['user_subjective_answer_images'] = questionData['user_subjective_answer_images'];
      } else {
        this.testObj['data']['questions'][questionIndex]['user_subjective_answer_images'] = null;
      }

      // Question Attempt status
      if (questionData['attempt'] && !questionData['s_review']) {
        if (this.completedCount.indexOf(question['id']) === -1) {
          this.completedCount.push(question['id']);
        }
        question['attempt'] = true;
      } else {
        question['attempt'] = false;
      }

      // Mark For Save & Review Status
      if (questionData['s_review']) {
        if (this.savedReviewCount.indexOf(question['id']) === -1) {
          this.savedReviewCount.push(question['id']);
        }

        question['sReview'] = true;
      }

      // Mark For Review Status
      if (questionData['review']) {
        if (this.reviewCount.indexOf(question['id']) === -1) {
          this.reviewCount.push(question['id']);
        }

        question['review'] = true;
      }
      observer.next(question);
    });
  }


  getSubjectList(data: any) {
    this.subjectObj = this.test.getSubjectList(data);
  }


  /**
   * Start Timer
   */
  timer(time: number) {

    this.test.setTime(time);
    this.testDuration = { ...this.test.update_clock() };

    this.test.timeinterval = setInterval(() => {
      this.testDuration = this.test.update_clock();
    }, 1000);
  }


  /**
   * Start Test and Setup Necessary Requirements
   */
  startTest(data) {


    this.testObj['started'] = true;
    this.testObj['attemptOrder'] = data['attempt_order'];
    this.testObj['data'] = data;
    // Update Service Obj
    this.test.testObj = this.testObj;

    this.syncQuiz();

    // Generate Subject List
    this.getSubjectList(data);

    // Set Total No. Of Questions
    this.totalQuestions = this.testObj['data'].questions.length;

    // Start Timer
    if (data['remaining_time'] !== 0) {
      this.timer(data['remaining_time']);
      // Show First Question
      this.showQuestion();
    } else {
      this.test.completeTest();
    }


  }


  /**
   * Updates Questions object according to current question
   */
  question_score: any;
  showQuestion() {
    // Intialize MathJax
    this.misc.initializeMathJax(this.mathjax.nativeElement).subscribe();
    this.question = this.testObj['data']['questions'][this.currentQuestion];
    this.question_score = this.getQuestionScore(this.question['type_of_question']);
    this.updateNotAnswered(this.question);

    // Mark Question as Visited
    this.question['visited'] = true;

    // Question Start At
    this.test.questionTimeStartAt = this.test.remainingSeconds;
    this.onclickClearallAnswer();
  }


  /**
   * View Next Question
   * Process Question if question type is Fill in the blanks
   */
  nextQuestion() {

    // Show Next Question
    if (this.currentQuestion < this.totalQuestions - 1) {
      this.currentQuestion++;
      if (this.subjectiveInputRef) {
        this.renderer.setProperty(this.subjectiveInputRef.nativeElement, 'value', '');
        this.renderer.setProperty(this.subjectiveInputImageRef.nativeElement, 'value', null);
      }
      this.showQuestion();
      window.scrollTo(0, 0);
    }


    if (this.fillUpInputRef) {
      // Reset Fill Input (if exists)
      try {
        this.fillUpInputRef.nativeElement.value = '';
      } catch (err) {
        console.log(err, "errr");
      }
    }

  }


  previousQuestion() {
    if (this.currentQuestion !== 0) {
      this.currentQuestion--;
      if (this.subjectiveInputRef) {
        this.renderer.setProperty(this.subjectiveInputRef.nativeElement, 'value', '');
        this.renderer.setProperty(this.subjectiveInputImageRef.nativeElement, 'value', null);
      };
    }
    this.showQuestion();
  }


  jumpToQuestion(questionIndex) {
    this.currentQuestion = questionIndex;
    this.showQuestion();
  }


  nextSubject(subjectIndex) {
    this.currentQuestion = subjectIndex;
    this.showQuestion()
  }


  completeTest() {
    this.alertService.showAlert({ text: 'Do you want to finish this test' }, 'info', 'confirm')
      .subscribe(data => {
        if (data) {
          this.test.completeTest();
        }
      });
  }


  /**
   * Get User Response from getUserAnswer()
   * Call processQuestions() for futher processing
   * Update Question Status
   * View Next Question
   */
  submitAnswer(question: object, event: any) {

    // Get Generated User Answers
    if (navigator.onLine) {
      const responseObj = this.getUserAnswer(question, event);
      if (!responseObj) {
        return false;
      }

      this.test.timeTakenInQuestion = this.test.questionTimeStartAt - this.test.remainingSeconds;

      // Process Questions
      this.toggleSubmit(event, true);
      this.test.processQuestions(question, this.selectedContentId, this.testStatus.sRreview, this.testStatus.review, responseObj).subscribe(data => {
        this.syncQuestions(this.currentQuestion, data).subscribe();

        // If User has not cleared the answer then its a successful submit & completed status can be updated
        if (!this.testStatus.cleared) {
          this.testStatus.completed = true;
        }

        // Update Question Status
        this.updateQuestionStatus(this.currentQuestion, event);
      });
    } else {
      this.alertService
        .showAlert({
          title: 'Network Error',
          text: 'Cannot Save Your Response! Check Your Internet Connection'
        },
          'info');
    }
    this.onclickClearallAnswer();

  }


  /**
   * Get User Response by calling generateUserResponse()
   * Check if User cleared any question then make user response array blank
   * Returned Clear Status (True/False) & User Response Object
   */
  getUserAnswer(question, event) {
    let userResponse = event ? this.generateUserAnswer(question, event) : [];
    if (userResponse.length == 0 && !this.testStatus.review) {
      this.alertService.showAlert({ text: 'You have not filled your answer' }, 'info').subscribe();
    } else {

      // Clear Current Question (If user hits clear button)
      if (this.testStatus.cleared) {
        event.target.reset();
        userResponse = [];
      }

      const responseObj = {
        response: userResponse,
        cleared: this.testStatus.cleared
      };
      return responseObj;
    }
  }


  /**
   * Generate User answers from form data
   * Takes Question & Event as Input
   * Fetches Selected Option Id using event
   * Returns seleted options of current quesions as a array
   * Clear input field for next question (Only if question was not marked for save & review )
   */
  generateUserAnswer(question: object, event: any) {

    const selectedAnswers = [];
    // Get User Answers for diffrent type of question
    if (question['type_of_question'] === 'mcq' || question['type_of_question'] === 'mcc') {
      event.target.elements.option.forEach(element => {
        if (element.checked) {
          selectedAnswers.push(element.id);
        }
      });
    } else if (question['type_of_question'] === 'flup') {
      if (this.fillUpInputRef.nativeElement.value) {
        const fillResponse = this.fillUpInputRef.nativeElement.value.trim();
        if (!/\S/.test(fillResponse)) {
          return [];
        }
        selectedAnswers.push(fillResponse);
      }
    } else if (question['type_of_question'] === 'numerical') {
      if (this.numericalInputRef.nativeElement.value) {
        const numericalResponse = this.numericalInputRef.nativeElement.value.trim();
        if (!/\S/.test(numericalResponse)) {
          return [];
        }
        selectedAnswers.push(numericalResponse);
      }
    } else if (question['type_of_question'] === 'subjective' || question['type_of_question'] === 'subjective_medium' || question['type_of_question'] === 'subjective_short' || question['type_of_question'] === 'subjective_very_short') {
      if (this.subjectiveInputRef.nativeElement.value) {
        const subjectiveResponse = this.subjectiveInputRef.nativeElement.value.trim();
        if (!/\S/.test(subjectiveResponse)) {
          return [];
        }
        selectedAnswers.push(subjectiveResponse);

        if (this.urls.length > 0) {
          const subjectiveImageResponse = this.parseImageIds(this.urls);
          selectedAnswers.push(subjectiveImageResponse);
        }
      }
    }
    return selectedAnswers;
  }

  parseImageIds(urls) {
    const itemList = [];
    urls.forEach(item => {
      itemList.push(JSON.parse(item['id']));
    });
    return itemList;
  }

  /**
   * Updates Question Status in sidebar
   */
  updateQuestionStatus(currentQuestion, event) {
    const question = this.testObj['data']['questions'][currentQuestion];

    // Delete Previous Marking Status
    delete question['review'];
    delete question['sReview'];
    delete question['completed'];
    delete question['attempt'];

    // Update New Marking Status
    if (this.testStatus.review) {

      this.updateReviewCount(question);
      question['review'] = true;

    } else if (this.testStatus.sRreview) {

      this.updateSaveAndMarkForReviewCount(question);
      question['sReview'] = true;

    } else if (this.testStatus.completed) {

      this.updateCompletedCount(question);
      question['completed'] = true;

      // Question Was Cleared
    } else if (this.testStatus.cleared) {

      this.updateCleared(question);

    }

    this.resetAndNext(question, event);

  }


  /**
   * Mark For Review
   */
  saveAndMarkForReview(event) {

    this.testStatus.sRreview = true;
  }


  /**
   * Mark For Review & Next
   */
  markForReviewAndNext() {

    this.clearResponse();
    this.testStatus.review = true;
  }


  /**
   * Clear User Reponse
   */
  clearResponse() {

    this.testStatus.cleared = true;
    this.onclickClearallAnswer();
  }


  updateNotAnswered(question) {

    if (!question['completed'] && !question['attempt'] && !question['sReview'] && !question['review']) {
      if (this.notAnswerdCount.indexOf(question['id']) === -1) {
        this.notAnswerdCount.push(this.question['id']);
      }
    }
  }


  /**
   * Rest Current Question Status & Make Ready for Next Question
   */
  resetAndNext(question, event) {

    this.toggleSubmit(event, false);

    // Show Next Question (In user did not clicked clear button & also not mark & save for review)
    if (question['completed'] || question['review'] || question['sReview']) {
      this.nextQuestion();
    }

    // Reset Fillup input field for next question
    if (event && !question['sReview'] && question['type_of_question'] === 'flup') {
      if (this.currentQuestion < this.totalQuestions - 1) {
        this.renderer.setProperty(this.fillUpInputRef.nativeElement, 'value', '');
      }
    }

    if (this.currentQuestion < this.totalQuestions - 1) {
      if (this.subjectiveInputRef) {
        this.renderer.setProperty(this.subjectiveInputRef.nativeElement, 'value', '');
        this.renderer.setProperty(this.subjectiveInputImageRef.nativeElement, 'value', null);
      }
    }


    // Reset All Status for Next Questions
    this.testStatus.review = false;
    this.testStatus.cleared = false;
    this.testStatus.sRreview = false;
    this.testStatus.completed = false;
  }


  /**
   * Update Review Count
   * CASES:
   * 1. Question will be counted as mark for review if not already marked (push in reviewCount)
   * 2. If Question is marked as save & review then remove it from savedReviewCount
   * 3. If Question is marked as completed then remove it from completedCount
   */
  updateReviewCount(question) {

    // Make List of Questions Marked for Review
    if (this.reviewCount.indexOf(question['id']) === -1) {
      this.reviewCount.push(question['id']);
    }

    // If Questions was maked for completed or Save & Mark for Review then remove it from both array
    if (this.savedReviewCount.includes(question['id'])) {
      _.pull(this.savedReviewCount, question['id']);
    }

    if (this.completedCount.includes(question['id'])) {
      _.pull(this.completedCount, question['id']);
    }

    if (this.notAnswerdCount.includes(question['id'])) {
      _.pull(this.notAnswerdCount, question['id']);
    }
  }


  /**
   * Update Save & Marked For Review Count
   * CASES:
   * 1. Question will be counted as save & mark for review if not already marked (push in savedReviewCount)
   * 2. If Question is marked as review then remove it from reviewCount
   * 3. If Question is marked as completed then remove it from completedCount
   * 4. If Question is marked notAnswered then remove it from notAnswerdCount
   */
  updateSaveAndMarkForReviewCount(question) {

    // Make List of Saved & Marked For Review questions
    if (this.savedReviewCount.indexOf(question['id']) === -1) {
      this.savedReviewCount.push(question['id']);
    }

    // If Questions was maked for review or completed then remove it from both array
    if (this.reviewCount.includes(question['id'])) {
      _.pull(this.reviewCount, question['id']);
    }

    if (this.completedCount.includes(question['id'])) {
      _.pull(this.completedCount, question['id']);
    }

    if (this.notAnswerdCount.includes(question['id'])) {
      _.pull(this.notAnswerdCount, question['id']);
    }
  }


  /**
   * Update Save & Marked For Review Count
   * CASES:
   * 1. Question will be counted as completed if not already marked (push in completedCount)
   * 2. If Question is marked as review then remove it from reviewCount
   * 3. If Question is marked as save & review then remove it from savedReviewCount
   * 4. If Question is marked notAnswered then remove it from notAnswerdCount
   */
  updateCompletedCount(question) {

    // Make List of Completed Questions
    if (this.completedCount.indexOf(question['id']) === -1) {
      this.completedCount.push(question['id']);
    }

    // If Questions was maked for review or Save & Mark for Review then remove it from both array
    if (this.reviewCount.includes(question['id'])) {
      _.pull(this.reviewCount, question['id']);
    }

    if (this.savedReviewCount.includes(question['id'])) {
      _.pull(this.savedReviewCount, question['id']);
    }

    if (this.notAnswerdCount.includes(question['id'])) {
      _.pull(this.notAnswerdCount, question['id']);
    }
  }


  /**
   * Update Save & Marked For Review Count
   * CASES:
   * 1. Question will be removed from completedCount, savedReviewCount, reviewCount & will be
     pushed in notAnswerdCount
    */
  updateCleared(question) {

    if (this.completedCount.includes(question['id'])) {
      _.pull(this.completedCount, question['id']);
    }

    if (this.reviewCount.includes(question['id'])) {
      _.pull(this.reviewCount, question['id']);
    }

    if (this.savedReviewCount.includes(question['id'])) {
      _.pull(this.savedReviewCount, question['id']);
    }

    // Add Question in Not Answerd List
    if (this.notAnswerdCount.indexOf(this.question['id']) === -1) {
      this.notAnswerdCount.push(this.question['id']);
    }
  }

  questionSubmissionStatus() {
    this.test.submittingQuestion.subscribe(
      data => {
        this.submittingQuestion = data;
      }
    );
  }


  /**
   * Get Question status circle color
   */
  getCircleClass(questionIndex) {

    const question = this.testObj['data']['questions'][questionIndex];
    if (question['review']) {
      return 'btn-review';
    } else if (question['sReview']) {
      return 'btn-review';
    } else if (question['completed'] || question['attempt']) {
      return 'btn-success';
    } else if (question['visited']) {
      return 'btn-dangerVisited';
    } else {
      return 'btn-not-visited';
    }
  }

  toggleSubmit(event, disable = true) {
    if (disable) {
      for (const i in event.target.elements) {
        if (event.target.elements[i]['type'] === 'submit') {
          this.renderer.setAttribute(event.target.elements[i], 'disabled', 'disabled');
        }
      }
    } else {
      for (const i in event.target.elements) {
        if (event.target.elements[i]['type'] === 'submit') {
          this.renderer.removeAttribute(event.target.elements[i], 'disabled');
        }
      }
    }
  }


  /**
   * Toggles Question status sidebar
   */
  toggleSidebar() {

    this.questionSidebarActive = !this.questionSidebarActive;

    if (this.questionSidebarActive) {
      this.renderer.removeClass(this.sidebarRef.nativeElement, 'sidebar-inactive');
      this.renderer.addClass(this.sidebarRef.nativeElement, 'sidebar-active');
    } else {
      this.renderer.removeClass(this.sidebarRef.nativeElement, 'sidebar-active');
      this.renderer.addClass(this.sidebarRef.nativeElement, 'sidebar-inactive');

    }
  }


  /**
   * Checks Network Status
   * Submit test when user comes online (If Test Time is over)
   */
  checkNetworkStatus() {

    this.renderer.listen('window', 'online', () => {

      this.misc.hideLoader();
      location.reload();
    });

    this.renderer.listen('window', 'offline', () => {
      this.misc.showLoader('disabled');
    });
  }


  toggleScreen() {
    this.maximizeScreen = !this.maximizeScreen;
  }


  enlargeImage(imgRef: HTMLImageElement) {

    if (imgRef.classList.contains('enlarge-image')) {
      this.renderer.removeClass(imgRef, 'enlarge-image')
    } else {
      this.renderer.addClass(imgRef, 'enlarge-image')
    }
  }

  preventBackButton() {
    history.pushState(null, null, location.href);
    this.locationStrategy.onPopState(() => {
      history.pushState(null, null, location.href);
    })
  }

  getQuestionScore(questionType) {
    if (this.testObj['type'] === 'mock') {
      if (questionType === 'mcq') {
        return this.testObj['data']['mockpaperdetails']['mcq_correct_answer_marks'];
      } else if (questionType === 'mcc') {
        return this.testObj['data']['mockpaperdetails']['mcc_correct_answer_marks'];
      } else if (questionType === 'flup') {
        return this.testObj['data']['mockpaperdetails']['flup_correct_answer_marks'];
      } else if (questionType === 'numerical') {
        return this.testObj['data']['mockpaperdetails']['numerical_correct_answer_marks'];
      } else if (questionType === 'subjective') {
        return this.testObj['data']['mockpaperdetails']['subjective_long_correct_answer_marks'];
      } else if (questionType === 'subjective_medium') {
        return this.testObj['data']['mockpaperdetails']['subjective_medium_correct_answer_marks'];
      } else if (questionType === 'subjective_short') {
        return this.testObj['data']['mockpaperdetails']['subjective_short_correct_answer_marks'];
      } else if (questionType === 'subjective_very_short') {
        return this.testObj['data']['mockpaperdetails']['subjective_very_short_correct_answer_marks'];
      }
    } else if (this.testObj['type'] === 'assessment') {
      if (questionType === 'mcq') {
        return this.testObj['data']['assessmentpaperdetails']['mcq_correct_answer_marks'];
      } else if (questionType === 'mcc') {
        return this.testObj['data']['assessmentpaperdetails']['mcc_correct_answer_marks'];
      } else if (questionType === 'flup') {
        return this.testObj['data']['assessmentpaperdetails']['flup_correct_answer_marks'];
      } else if (questionType === 'numerical') {
        return this.testObj['data']['assessmentpaperdetails']['numerical_correct_answer_marks'];
      } else if (questionType === 'subjective') {
        return this.testObj['data']['assessmentpaperdetails']['subjective_long_correct_answer_marks'];
      } else if (questionType === 'subjective_medium') {
        return this.testObj['data']['assessmentpaperdetails']['subjective_medium_correct_answer_marks'];
      } else if (questionType === 'subjective_short') {
        return this.testObj['data']['assessmentpaperdetails']['subjective_short_correct_answer_marks'];
      } else if (questionType === 'subjective_very_short') {
        return this.testObj['data']['assessmentpaperdetails']['subjective_very_short_correct_answer_marks'];
      }
    }
  }

  ngOnInit() {
    this.questionSidebarActive = !this.isMobile;

    this.route.params.subscribe(
      data => {
        this.testObj = { ...data };
        this.getTest();
      }
    );

    // Get User Profile
    this.misc.userProfile().subscribe(
      data => {
        this.userProfileObj = data;
      }
    );

    this.questionSubmissionStatus();

    // Check Network Status
    this.checkNetworkStatus();

    if (this.isMobile) {
      this.maximizeScreen = true;
    }

    this.preventBackButton();
  }
}
